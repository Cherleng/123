#### C++初学笔记 - The_Sky

1.int整型相除结果取整舍小数

2.两个小数不能做取模运算

3.前置递增++a:让变量a(此处为a)+1
  前置与后置递增的区别:
前置先让变量+1然后进行表达式运算

4.非真即假，a=10，10>0为真；!a=0，a取反则为假即为0，!!a非假值为1(非零则为真)

5.switch语句中只能放整型或字符

6.while循环当条件为真时才执行，在"输出0-9"的实例中，当num完成while循环后其值为10

7.rand() % 100 //此处将会随机生成一个0-99的数字
(rand为伪随机)

8.获取三位数的个位:对数字取模于10
十位:先整除10在取模于10(解析：先转化为两位数在进行获取个位数的操作)
百位:除以100

9.若使用优化好的主流编译器则在循环内定义变量不会被重复分配

10.嵌套循环中的i可以重复使用，可能是独立于循环中的，编译器允许套娃，但是最好不要，会降低程序可读性.(套娃循环)

11.嵌套循环中输出的相同的变量(例如i)，存在就近原则，即输出最近的i

12.在初始化数组数据的时候，没有填写的数据(连续的末尾的数)会用0补充

13.内存地址是随机分配 ，每次运行都会发生改变

14.数组名是常量不能进行赋值

15.指针实质是用于保存地址的变量，但因起特殊用途所以另起概念，某种层面上:指针==变量==地址

16.&:取址 *取值，指针在指向数组的时候可不加&//详见第29条，在指向数组中某一元素的时候用&

17.解引用: 把地址对应的内容解出来，并 引用 ； 即*p== p(指针)对应(或指向)的内容（*p就是p对用内容的引用）

18.空指针好比：int a = 0，但是指针开始的时候没有地址给他"指"，指向null就和给a赋的值0的意义差不多

19.函数中参数为数组时，数组自动退化成数组中第一个数据的首地址，:arr[i] == *(arr+i)即访问arr[第一个数据+i]中的数据；这也是为什么i<len(数组长度)的原因，因为传递的形参是第一个数据的地址，此时数组的数据个数就等于len-1.(注意点:第一个数组计数点为0;用数组长度//假定为3；求最后一个元素则表示为3-1//0,1,2中2是最后一个元素，但他有三个元素所以需要减1)

20.结构体:创建结构体变量的时候关键字可省略，而结构体变量定义的时候不可省略

21.在main()函数里定义的同名变量会屏蔽掉main函数外的全局变量，(在外定义的是全局在内定义的是局部，)

22.当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值
[
int 0
char ''
float、double 0.0
pointer nullptr （C语言是NULL）//NULL和nullptr在指针层面上代表的都是空值,但是因为Null本身是广泛意义上的空值（0之类的）所带来的在c++上的局限性，c++定义了一种新的专门的空指针值类型
]

23.在函数内使用同名的全局变量和局部变量:在全局变量之前加上域名解析则引用全局变量（::a是全局
）
24.static修饰的全局静态变量只在当前源文件内使用；静态修饰符用于将函数内的值从栈区放到全局区（不会因为离开作用域而被释放或回收掉），变为全局变量，可以返回该变量并可在外部操作该变量

25.在一个文件中有某变量的定义，则在其他使用到该变量的文件中应声明该变量(此时不可赋值)

26.普通数组中以数组名用cout来输出，只会得到一串地址；用字符数组则会输出数组中的内容.

27.指针不同的数据类型指向的变量或常量的数据类型不同，可以记为:某类型的指针指向同类型的数据

28.形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作

29. &height[0] 就是取得是数组第一个元素的地址，假设地址为 1000；&height 是直接对数组名进行取地址，这个时候就是取得是 height 整个数组的地址，指向包含 10 个元素的 int 型数组，height 等价于 &height[0]，height+1 会将地址加 4 个字节（不一定是四个，视类型而定）；但 &height+1 就是将地址增加 10*4 个字节（取地址符优先级大于加号个，故取地址符按照其结合律先与height结合之后对结合值进行加1操作）

30.传递参数和传递地址的区别:传递参数时复制实参，如果传入数据过多会影响执行效率；当传递参数过多时使用传递地址，这样只传入四个字节，或者用facetoface

31.类的权限分为:公有、私有、保护权限，公有权限类内和类外都可以访问，保护和私有只能类内访问(区别在于保护权限子对象也可以访问，而私有权限子对象不可以访问)，类内访问即使用构造函数:例如在函数体内使用赋值语句"属性 = 外部变量"，然后通过调用该函数实现类内访问

32.结构体中可以通过函数指针来实现类中"构造函数"这一功能

33.如果释放数组的时候没有delete []则只会释放数组中第一个元素，后续成为野指针

34.函数返回引用的时候，函数名前需要加上&符，此时函数名即为返回值(函数内return后的东西)的一个引用；用引用(1)来接收引用(2函数名)，更改1的值就会更改2的值就会更改2引用的值；上一句话也可以直接更改2(也就是函数名)的值，此时函数可以作为左值

35.引用的本质为指针常量(即指针指向不可改变，值可以改变)

36.只有非静态成员 变量 存储于类，静态函数和非静态函数、静态成员都不存储于类

37.  int* a = new int[10] { 1,2,3,4,5,6,7,8,9,10 };可对动态（new出来的）数组进行值初始化，此方法是“new int[10]()//每个元素都初始化为0”的拓展，在c++11后支持
